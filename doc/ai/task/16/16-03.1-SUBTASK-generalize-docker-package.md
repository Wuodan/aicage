# Subtask 16-03.1: Generalize docker package

You suggesting to copy method `decide_pull` (copying = mirror) made me analyze the very recent
migration to all docker-interactions into one package.

And we must now first take a step back and fine-tune that migration, because the
docker-interactions are to much based on the rest of the code to be really reusable.

The most important issue is the usage of `RunConfig` and `GlobalConfig` throughout the new
`docker` package.

## Analysis

When searching in the `docker` package by regex for `(RunConfig|GlobalConfig)` and then again
searching in `docker` package for `(run_?config|global_?config)\.` to see where values from those
objects are used I see this:

- `image_ref`
- `image_repository`
- `image_registry`
- plus `build.py` where we use a few more for image building.

### build.py

`build.py` is a bit special here, so leave RunConfig/GlobalConfig in there for now.

But method `local_image_exists` is not building images so should not be in that module.

### Replace usage of `RunConfig` and `GlobalConfig` in `docker` package

Apart from `builder.py`, replace the usage of the 2 config objects.  
By clean code I generally try to avoid having many parameters to methods, especially global ones.
My personal limit for Java would be 2 parameters (weak rule) and I'm willing to create pojos if
there are more.

And:

- `image_ref`
- `image_repository`
- `image_registry`
being closely related, in some instances even concatenated to one string as in:

```python
def get_local_repo_digest(run_config: RunConfig) -> str | None:
    repository = f"{run_config.global_cfg.image_registry}/{run_config.global_cfg.image_repository}"
    return get_local_repo_digest_for_repo(run_config.image_ref, repository)


def get_local_repo_digest_for_repo(image_ref: str, repository: str) -> str | None:
```

I want you to consider using dataclasses to wrap often used argument combinations.

## Subtask Guidelines and Workflow

Don't forget to read `AGENTS.md` and `doc/python-test-structure-guidelines.md`; always use the existing venv.

You shall follow this order:

1. Read documentation and code to understand the task.
2. Ask me questions if something is not clear to you
3. Present me with an implementation solution - this needs my approval
4. Implement the change autonomously including a loop of running-tests, fixing bugs, running tests
5. Run linters with `scripts/lint.sh`
6. Present me the change for review
7. Interactively react to my review feedback
8. Do not commit any changes unless explicitly instructed by the user.
